
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.models.torch_forecasting_model &#8212; darts  documentation</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../../index.html">
    
      <img src="../../../_static/darts-logo-trim.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../README.html">Home</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../generated_api/darts.html">API Reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../examples.html">Examples</a>
        </li>
        
        
      </ul>


      <form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/unit8co/darts" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
          <li class="nav-item">
            <a class="nav-link" href="https://twitter.com/unit8co" target="_blank" rel="noopener">
              <span><i class="fab fa-twitter-square"></i></span>
            </a>
          </li>
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.models.torch_forecasting_model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains several abstract classes:</span>

<span class="sd">    * TorchForecastingModel is the super-class of all torch (deep learning) darts forecasting models.</span>

<span class="sd">    * PastCovariatesTorchModel(TorchForecastingModel) for torch models consuming only past-observed covariates.</span>
<span class="sd">    * FutureCovariatesTorchModel(TorchForecastingModel) for torch models consuming only future values of</span>
<span class="sd">      future covariates.</span>
<span class="sd">    * DualCovariatesTorchModel(TorchForecastingModel) for torch models consuming past and future values of some single</span>
<span class="sd">      future covariates.</span>
<span class="sd">    * MixedCovariatesTorchModel(TorchForecastingModel) for torch models consuming both past-observed</span>
<span class="sd">      as well as past and future values of some future covariates.</span>
<span class="sd">    * SplitCovariatesTorchModel(TorchForecastingModel) for torch models consuming past-observed as well as future</span>
<span class="sd">      values of some future covariates.</span>

<span class="sd">    * TorchParametricProbabilisticForecastingModel(TorchForecastingModel) is the super-class of all probabilistic torch</span>
<span class="sd">      forecasting models.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torch.utils.tensorboard</span> <span class="kn">import</span> <span class="n">SummaryWriter</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">from</span> <span class="nn">..timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">_build_tqdm_iterator</span>
<span class="kn">from</span> <span class="nn">..utils.torch</span> <span class="kn">import</span> <span class="n">random_method</span>

<span class="kn">from</span> <span class="nn">..utils.data.training_dataset</span> <span class="kn">import</span> <span class="p">(</span><span class="n">TrainingDataset</span><span class="p">,</span>
                                           <span class="n">PastCovariatesTrainingDataset</span><span class="p">,</span>
                                           <span class="n">FutureCovariatesTrainingDataset</span><span class="p">,</span>
                                           <span class="n">DualCovariatesTrainingDataset</span><span class="p">,</span>
                                           <span class="n">MixedCovariatesTrainingDataset</span><span class="p">,</span>
                                           <span class="n">SplitCovariatesTrainingDataset</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils.data.inference_dataset</span> <span class="kn">import</span> <span class="p">(</span><span class="n">InferenceDataset</span><span class="p">,</span>
                                            <span class="n">PastCovariatesInferenceDataset</span><span class="p">,</span>
                                            <span class="n">FutureCovariatesInferenceDataset</span><span class="p">,</span>
                                            <span class="n">DualCovariatesInferenceDataset</span><span class="p">,</span>
                                            <span class="n">MixedCovariatesInferenceDataset</span><span class="p">,</span>
                                            <span class="n">SplitCovariatesInferenceDataset</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils.data.sequential_dataset</span> <span class="kn">import</span> <span class="p">(</span><span class="n">PastCovariatesSequentialDataset</span><span class="p">,</span>
                                             <span class="n">FutureCovariatesSequentialDataset</span><span class="p">,</span>
                                             <span class="n">DualCovariatesSequentialDataset</span><span class="p">,</span>
                                             <span class="n">MixedCovariatesSequentialDataset</span><span class="p">,</span>
                                             <span class="n">SplitCovariatesSequentialDataset</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..utils.likelihood_models</span> <span class="kn">import</span> <span class="n">LikelihoodModel</span>
<span class="kn">from</span> <span class="nn">..logging</span> <span class="kn">import</span> <span class="n">raise_if_not</span><span class="p">,</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_log</span><span class="p">,</span> <span class="n">raise_if</span>
<span class="kn">from</span> <span class="nn">.forecasting_model</span> <span class="kn">import</span> <span class="n">GlobalForecastingModel</span>

<span class="n">DEFAULT_DARTS_FOLDER</span> <span class="o">=</span> <span class="s1">&#39;.darts&#39;</span>
<span class="n">CHECKPOINTS_FOLDER</span> <span class="o">=</span> <span class="s1">&#39;checkpoints&#39;</span>
<span class="n">RUNS_FOLDER</span> <span class="o">=</span> <span class="s1">&#39;runs&#39;</span>
<span class="n">UNTRAINED_MODELS_FOLDER</span> <span class="o">=</span> <span class="s1">&#39;untrained_models&#39;</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_checkpoint_folder</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">model_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">CHECKPOINTS_FOLDER</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_untrained_models_folder</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">model_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">UNTRAINED_MODELS_FOLDER</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_runs_folder</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">model_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">RUNS_FOLDER</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TorchForecastingModel</span><span class="p">(</span><span class="n">GlobalForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="c1"># TODO: add is_stochastic &amp; reset methods</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">input_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
                 <span class="n">n_epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                 <span class="n">optimizer_cls</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">,</span>
                 <span class="n">optimizer_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">lr_scheduler_cls</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">_LRScheduler</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">lr_scheduler_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">loss_fn</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">_Loss</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">(),</span>
                 <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">work_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">DEFAULT_DARTS_FOLDER</span><span class="p">),</span>
                 <span class="n">log_tensorboard</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">nr_epochs_val_period</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="n">torch_device_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">force_reset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; Pytorch-based Forecasting Model.</span>

<span class="sd">        This class is meant to be inherited to create a new pytorch-based forecasting module.</span>
<span class="sd">        When subclassing this class, please make sure to set the self.model attribute</span>
<span class="sd">        in the __init__ function and then call super().__init__ while passing the kwargs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Number of past time steps that are fed to the internal forecasting module.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Number of time steps to be output by the internal forecasting module.</span>
<span class="sd">        batch_size</span>
<span class="sd">            Number of time series (input and output sequences) used in each training pass.</span>
<span class="sd">        n_epochs</span>
<span class="sd">            Number of epochs over which to train the model.</span>
<span class="sd">        optimizer_cls</span>
<span class="sd">            The PyTorch optimizer class to be used (default: `torch.optim.Adam`).</span>
<span class="sd">        optimizer_kwargs</span>
<span class="sd">            Optionally, some keyword arguments for the PyTorch optimizer (e.g., `{&#39;lr&#39;: 1e-3}`</span>
<span class="sd">            for specifying a learning rate). Otherwise the default values of the selected `optimizer_cls`</span>
<span class="sd">            will be used.</span>
<span class="sd">        lr_scheduler_cls</span>
<span class="sd">            Optionally, the PyTorch learning rate scheduler class to be used. Specifying `None` corresponds</span>
<span class="sd">            to using a constant learning rate.</span>
<span class="sd">        lr_scheduler_kwargs</span>
<span class="sd">            Optionally, some keyword arguments for the PyTorch optimizer.</span>
<span class="sd">        loss_fn</span>
<span class="sd">            PyTorch loss function used for training.</span>
<span class="sd">            This parameter will be ignored for probabilistic models if the `likelihood` parameter is specified.</span>
<span class="sd">            Default: `torch.nn.MSELoss()`.</span>
<span class="sd">        model_name</span>
<span class="sd">            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,</span>
<span class="sd">            defaults to the following string &quot;YYYY-mm-dd_HH:MM:SS_torch_model_run_PID&quot;, where the initial part of the</span>
<span class="sd">            name is formatted with the local date and time, while PID is the processed ID (preventing models spawned at</span>
<span class="sd">            the same time by different processes to share the same model_name). E.g.,</span>
<span class="sd">            2021-06-14_09:53:32_torch_model_run_44607.</span>
<span class="sd">        work_dir</span>
<span class="sd">            Path of the working directory, where to save checkpoints and Tensorboard summaries.</span>
<span class="sd">            (default: current working directory).</span>
<span class="sd">        log_tensorboard</span>
<span class="sd">            If set, use Tensorboard to log the different parameters. The logs will be located in:</span>
<span class="sd">            `[work_dir]/.darts/runs/`.</span>
<span class="sd">        nr_epochs_val_period</span>
<span class="sd">            Number of epochs to wait before evaluating the validation loss (if a validation</span>
<span class="sd">            `TimeSeries` is passed to the `fit()` method).</span>
<span class="sd">        torch_device_str</span>
<span class="sd">            Optionally, a string indicating the torch device to use. (default: &quot;cuda:0&quot; if a GPU</span>
<span class="sd">            is available, otherwise &quot;cpu&quot;)</span>
<span class="sd">        force_reset</span>
<span class="sd">            If set to `True`, any previously-existing model with the same name will be reset (all checkpoints will</span>
<span class="sd">            be discarded).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">torch_device_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_best_torch_device</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">torch_device_str</span><span class="p">)</span>

        <span class="c1"># We will fill these dynamically, upon first call of fit_from_dataset():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span> <span class="o">=</span> <span class="n">input_chunk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span> <span class="o">=</span> <span class="n">output_chunk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_tensorboard</span> <span class="o">=</span> <span class="n">log_tensorboard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nr_epochs_val_period</span> <span class="o">=</span> <span class="n">nr_epochs_val_period</span>

        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">_%H.%M.%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">current_time</span> <span class="o">+</span> <span class="s2">&quot;_torch_model_run_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span> <span class="o">=</span> <span class="n">work_dir</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span> <span class="o">=</span> <span class="n">n_epochs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 0 means it wasn&#39;t trained yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>

        <span class="c1"># Define the loss function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">loss_fn</span>

        <span class="c1"># The tensorboard writer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tb_writer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Persist optimiser and LR scheduler parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_cls</span> <span class="o">=</span> <span class="n">optimizer_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">optimizer_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">optimizer_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler_cls</span> <span class="o">=</span> <span class="n">lr_scheduler_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">lr_scheduler_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lr_scheduler_kwargs</span>

        <span class="c1"># by default models are deterministic (i.e. not probabilistic)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">force_reset</span> <span class="o">=</span> <span class="n">force_reset</span>
        <span class="n">checkpoints_folder</span> <span class="o">=</span> <span class="n">_get_checkpoint_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_exists</span> <span class="o">=</span> \
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">checkpoints_folder</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">checkpoints_folder</span><span class="p">,</span> <span class="s2">&quot;checkpoint_*&quot;</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_exists</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_reset</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset_model</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You already have model data for the &#39;</span><span class="si">{}</span><span class="s2">&#39; name. Either load model to continue&quot;</span>
                                     <span class="s2">&quot; training or use `force_reset=True` to initialize anyway to start&quot;</span>
                                     <span class="s2">&quot; training from scratch and remove all the model data&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">)</span>
                                     <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_batch_collate_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a batch Tuple from a list of samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aggregated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">first_sample</span> <span class="o">=</span> <span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first_sample</span><span class="p">)):</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">first_sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">aggregated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aggregated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="n">aggregated</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">aggregated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets the model object and removes all the stored data - model, checkpoints and training history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">_get_checkpoint_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">),</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">_get_runs_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">),</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">_get_untrained_models_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">),</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_exists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_init_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Init self.model - the torch module of this class, based on examples of input/output tensors (to get the</span>
<span class="sd">        sizes right).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the tensors have shape (chunk_length, nr_dimensions)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Time series values are 32-bits; casting model to float32.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Time series values are 64-bits; casting model to float64. If training is too slow you &#39;</span>
                        <span class="s1">&#39;can try casting your data to 32-bits.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">double</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># A utility function to create optimizer and lr scheduler from desired classes</span>
        <span class="k">def</span> <span class="nf">_create_from_cls_and_kwargs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">kws</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error when building the optimizer or learning rate scheduler;&#39;</span>
                                     <span class="s1">&#39;please check the provided class and arguments&#39;</span>
                                     <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">class: </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">arguments (kwargs): </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">error:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">kws</span><span class="p">,</span> <span class="n">e</span><span class="p">)),</span>
                          <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># Create the optimizer and (optionally) the learning rate scheduler</span>
        <span class="c1"># we have to create copies because we cannot save model.parameters into object state (not serializable)</span>
        <span class="n">optimizer_kws</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">optimizer_kws</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">_create_from_cls_and_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer_cls</span><span class="p">,</span> <span class="n">optimizer_kws</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lr_sched_kws</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">lr_sched_kws</span><span class="p">[</span><span class="s1">&#39;optimizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler</span> <span class="o">=</span> <span class="n">_create_from_cls_and_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler_cls</span><span class="p">,</span> <span class="n">lr_sched_kws</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># We won&#39;t use a LR scheduler</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_untrained_model</span><span class="p">(</span><span class="n">_get_untrained_models_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">))</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_create_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method has to be implemented by all children. It is in charge of instantiating the actual torch model,</span>
<span class="sd">        based on examples input/output tensors (i.e. implement a model with the right input/output sizes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">TrainingDataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each model must specify the default training dataset to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">InferenceDataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each model must specify the default training dataset to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the provided train dataset is of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the provided inference dataset is of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        verify that the (first) sample contained in the inference dataset matches the model type and the</span>
<span class="sd">        data the model has been trained on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that any non-None covariates comply with the model type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_produce_train_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In charge of apply the recurrent logic for non-recurrent models.</span>
<span class="sd">        Should be overwritten by recurrent models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@random_method</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
            <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">val_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">val_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">val_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The fit method for torch models. It wraps around `fit_from_dataset()`, constructing a default training</span>
<span class="sd">        dataset for this model. If you need more control on how the series are sliced for training, consider</span>
<span class="sd">        calling `fit_from_dataset()` with a custom `darts.utils.data.TrainingDataset`.</span>

<span class="sd">        This function can be called several times to do some extra training. If `epochs` is specified, the model</span>
<span class="sd">        will be trained for some (extra) `epochs` epochs.</span>

<span class="sd">        Below, all possible parameters are documented, but not all models support all parameters. For instance,</span>
<span class="sd">        all the `PastCovariatesTorchModel` support only `past_covariates` and not `future_covariates`. Darts will</span>
<span class="sd">        complain if you try fitting a model with the wrong covariates argument.</span>

<span class="sd">        When handling covariates, Darts tries to be &quot;smart&quot; and uses the time axes of the target and the covariates</span>
<span class="sd">        to come up with the right time slices. So the covariates can be longer than needed; as long as the time axes</span>
<span class="sd">        are correct Darts will handle them correctly. It will also complain if their time span is not sufficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        series</span>
<span class="sd">            A series or sequence of series serving as target (i.e. what the model will be trained to forecast)</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, a series or sequence of series specifying past-observed covariates</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, a series or sequence of series specifying future-known covariates</span>
<span class="sd">        val_series</span>
<span class="sd">            Optionally, one or a sequence of validation target series, which will be used to compute the validation</span>
<span class="sd">            loss throughout training and keep track of the best performing models.</span>
<span class="sd">        val_past_covariates</span>
<span class="sd">            Optionally, the past covariates corresponding to the validation series (must match `covariates`)</span>
<span class="sd">        val_future_covariates</span>
<span class="sd">            Optionally, the future covariates corresponding to the validation series (must match `covariates`)</span>
<span class="sd">        verbose</span>
<span class="sd">            Optionally, whether to print progress.</span>
<span class="sd">        epochs</span>
<span class="sd">            If specified, will train the model for `epochs` (additional) epochs, irrespective of what `n_epochs`</span>
<span class="sd">            was provided to the model constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">)</span>

        <span class="c1"># TODO: also check the validation covariates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_past_future_covariates</span><span class="p">(</span><span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">)</span>

        <span class="n">wrap_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="p">[</span><span class="n">ts</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">ts</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
        <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>
        <span class="n">val_series</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">val_series</span><span class="p">)</span>
        <span class="n">val_past_covariates</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">val_past_covariates</span><span class="p">)</span>
        <span class="n">val_future_covariates</span> <span class="o">=</span> <span class="n">wrap_fn</span><span class="p">(</span><span class="n">val_future_covariates</span><span class="p">)</span>

        <span class="c1"># Check that dimensions of train and val set match; on first series only</span>
        <span class="k">if</span> <span class="n">val_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">val_series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="ow">and</span>
                     <span class="p">(</span><span class="n">past_covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="n">past_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span>
                     <span class="p">(</span><span class="n">val_past_covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="n">val_past_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="p">(</span><span class="n">future_covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="n">future_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span>
                     <span class="p">(</span><span class="n">val_future_covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="n">val_future_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="s1">&#39;The dimensions of the series in the training set &#39;</span>
                                <span class="s1">&#39;and the validation set do not match.&#39;</span><span class="p">)</span>

        <span class="n">train_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_train_dataset</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">)</span>
        <span class="n">val_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_train_dataset</span><span class="p">(</span><span class="n">val_series</span><span class="p">,</span> <span class="n">val_past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">)</span> <span class="k">if</span> <span class="n">val_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Train dataset contains </span><span class="si">{}</span><span class="s1"> samples.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_from_dataset</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">val_dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">epochs</span><span class="p">)</span>

    <span class="nd">@random_method</span>
    <span class="k">def</span> <span class="nf">fit_from_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">,</span>
                         <span class="n">val_dataset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrainingDataset</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method allows for training with a specific `darts.utils.data.TrainingDataset` instance. These datasets</span>
<span class="sd">        implement a PyTorch `Dataset`, and specify how the target and covariates are sliced for training. If you</span>
<span class="sd">        are not sure which training dataset to use, consider calling `fit()` instead, which will create a default</span>
<span class="sd">        training dataset appropriate for this model.</span>

<span class="sd">        This function can be called several times to do some extra training. If `epochs` is specified, the model</span>
<span class="sd">        will be trained for some (extra) `epochs` epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        train_dataset</span>
<span class="sd">            A training dataset with a type matching this model (e.g. `PastCovariatesTrainingDataset` for</span>
<span class="sd">            `PastCovariatesTorchModel`s).</span>
<span class="sd">        val_dataset</span>
<span class="sd">            A training dataset with a type matching this model (e.g. `PastCovariatesTrainingDataset` for</span>
<span class="sd">            `PastCovariatesTorchModel`s), representing the validation set (to track the validation loss).</span>
<span class="sd">        verbose</span>
<span class="sd">            Optionally, whether to print progress.</span>
<span class="sd">        epochs</span>
<span class="sd">            If specified, will train the model for `epochs` (additional) epochs, irrespective of what `n_epochs`</span>
<span class="sd">            was provided to the model constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_train_dataset_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">)</span>
        <span class="n">raise_if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="s1">&#39;The provided training time series dataset is too short for obtaining even one training point.&#39;</span><span class="p">,</span>
                 <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if</span><span class="p">(</span><span class="n">val_dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="s1">&#39;The provided validation time series dataset is too short for obtaining even one training point.&#39;</span><span class="p">,</span>
                 <span class="n">logger</span><span class="p">)</span>

        <span class="n">train_sample</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Build model, based on the dimensions of the first series in the train set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="n">train_sample</span><span class="p">,</span> <span class="n">train_sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_model</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check existing model has input/output dims matching what&#39;s provided in the training set.</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_sample</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">),</span>
                         <span class="s1">&#39;The size of the training set samples (tuples) does not match what the model has been &#39;</span>
                         <span class="s1">&#39;previously trained on. Trained on tuples of length </span><span class="si">{}</span><span class="s1">, received tuples of length </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_sample</span><span class="p">)</span>
                         <span class="p">))</span>
            <span class="n">same_dims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">train_sample</span><span class="p">)</span> <span class="o">==</span>
                         <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">))</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="n">same_dims</span><span class="p">,</span>
                         <span class="s1">&#39;The dimensionality of the series in the training set do not match the dimensionality&#39;</span>
                         <span class="s1">&#39; of the series the model has previously been trained on. &#39;</span>
                         <span class="s1">&#39;Model input/output dimensions = </span><span class="si">{}</span><span class="s1">, provided input/ouptput dimensions = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">),</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">train_sample</span><span class="p">)</span>
                         <span class="p">))</span>

        <span class="c1"># Setting drop_last to False makes the model see each sample at least once, and guarantee the presence of at</span>
        <span class="c1"># least one batch no matter the chosen batch size</span>
        <span class="n">train_loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span>
                                  <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                                  <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                  <span class="n">pin_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">drop_last</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">collate_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_collate_fn</span><span class="p">)</span>

        <span class="c1"># Prepare validation data</span>
        <span class="n">val_loader</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">val_dataset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">val_dataset</span><span class="p">,</span>
                                                                 <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                                                                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                 <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                 <span class="n">pin_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">drop_last</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                 <span class="n">collate_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_collate_fn</span><span class="p">)</span>

        <span class="c1"># Prepare tensorboard writer</span>
        <span class="n">tb_writer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_tensorboard_writer</span><span class="p">()</span>

        <span class="c1"># if user wants to train the model for more epochs, ignore the n_epochs parameter</span>
        <span class="n">train_num_epochs</span> <span class="o">=</span> <span class="n">epochs</span> <span class="k">if</span> <span class="n">epochs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_epochs</span>

        <span class="c1"># Train model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">(</span><span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">,</span> <span class="n">tb_writer</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">train_num_epochs</span><span class="p">)</span>

        <span class="c1"># Close tensorboard writer</span>
        <span class="k">if</span> <span class="n">tb_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tb_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">tb_writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@random_method</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="n">series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">roll_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts values for a certain number of time steps after the end of the training series,</span>
<span class="sd">        or after the end of the specified `series`.</span>

<span class="sd">        Below, all possible parameters are documented, but not all models support all parameters. For instance,</span>
<span class="sd">        all the `PastCovariatesTorchModel` support only `past_covariates` and not `future_covariates`. Darts will</span>
<span class="sd">        complain if you try calling `predict() on a model with the wrong covariates argument.</span>

<span class="sd">        Darts will also complain if the provided covariates do not have a sufficient time span.</span>
<span class="sd">        In general, not all models require the same covariates&#39; time spans:</span>

<span class="sd">        * Models relying on past covariates require the last `input_chunk_length` of the `past_covariates` points to be known at prediction time. For horizon values `n &gt; output_chunk_length`, these models require at least the next `n - output_chunk_length` future values to be known as well.</span>

<span class="sd">        * Models relying on future covariates require the next `n` values to be known. In addition (for `DualCovariatesTorchModel` and `MixedCovariatesTorchModel`), they also require the &quot;historic&quot; values of these future covariates (over the past `input_chunk_length`).</span>

<span class="sd">        When handling covariates, Darts tries to be &quot;smart&quot; and uses the time axes of the target and the covariates</span>
<span class="sd">        to come up with the right time slices. So the covariates can be longer than needed; as long as the time axes</span>
<span class="sd">        are correct Darts will handle them correctly. It will also complain if their time span is not sufficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The number of time steps after the end of the training time series for which to produce predictions</span>
<span class="sd">        series</span>
<span class="sd">            Optionally, one or several input `TimeSeries`, representing the history of the target series whose</span>
<span class="sd">            future is to be predicted. If specified, the method returns the forecasts of these</span>
<span class="sd">            series. Otherwise, the method returns the forecast of the (single) training series.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, the past-observed covariates series needed as inputs for the model.</span>
<span class="sd">            They must match the covariates used for training in terms of dimension and type.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, the future-known covariates series needed as inputs for the model.</span>
<span class="sd">            They must match the covariates used for training in terms of dimension and type.</span>
<span class="sd">        batch_size</span>
<span class="sd">            Size of batches during prediction. Defaults to the models `batch_size` value.</span>
<span class="sd">        verbose</span>
<span class="sd">            Optionally, whether to print progress.</span>
<span class="sd">        n_jobs</span>
<span class="sd">            The number of jobs to run in parallel. Defaults to `1`. `-1` means using all processors.</span>
<span class="sd">        roll_size</span>
<span class="sd">            For self-consuming predictions, i.e. `n &gt; self.output_chunk_length`, determines how many</span>
<span class="sd">            outputs of the model are fed back into it at every iteration of feeding the predicted target</span>
<span class="sd">            (and optionally future covariates) back into the model. If this parameter is not provided,</span>
<span class="sd">            it will be set `self.output_chunk_length` by default.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from a probabilistic model. Should be left set to 1</span>
<span class="sd">            for deterministic models.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[TimeSeries, Sequence[TimeSeries]]</span>
<span class="sd">            One or several time series containing the forecasts of `series`, or the forecast of the training series</span>
<span class="sd">            if `series` is not specified and the model has been trained on a single series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Input series has to be provided after fitting on multiple series.&quot;</span><span class="p">)</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_series</span>

        <span class="k">if</span> <span class="n">past_covariates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_covariate_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">past_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_covariate_series</span>
        <span class="k">if</span> <span class="n">future_covariates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_covariate_series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">future_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_covariate_series</span>

        <span class="n">called_with_single_series</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">called_with_single_series</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="p">]</span>

        <span class="n">past_covariates</span> <span class="o">=</span> <span class="p">[</span><span class="n">past_covariates</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">past_covariates</span>
        <span class="n">future_covariates</span> <span class="o">=</span> <span class="p">[</span><span class="n">future_covariates</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">future_covariates</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_inference_dataset</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
                                                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                                <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">)</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_from_dataset</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                                <span class="n">roll_size</span><span class="o">=</span><span class="n">roll_size</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">called_with_single_series</span> <span class="k">else</span> <span class="n">predictions</span>

    <span class="k">def</span> <span class="nf">predict_from_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">input_series_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">,</span>
                             <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">roll_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]:</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method allows for predicting with a specific `darts.utils.data.InferenceDataset` instance. These datasets</span>
<span class="sd">        implement a PyTorch `Dataset`, and specify how the target and covariates are sliced for inference.</span>
<span class="sd">        In most cases, you&#39;ll rather want to call `predict()` instead, which will create an appropriate `InferenceDataset`</span>
<span class="sd">        for you.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The number of time steps after the end of the training time series for which to produce predictions</span>
<span class="sd">        input_series_dataset</span>
<span class="sd">            Optionally, one or several input `TimeSeries`, representing the history of the target series&#39; whose</span>
<span class="sd">            future is to be predicted. If specified, the method returns the forecasts of these</span>
<span class="sd">            series. Otherwise, the method returns the forecast of the (single) training series.</span>
<span class="sd">        batch_size</span>
<span class="sd">            Size of batches during prediction. Defaults to the models `batch_size` value.</span>
<span class="sd">        verbose</span>
<span class="sd">            Shows the progress bar for batch predicition. Off by default.</span>
<span class="sd">        n_jobs</span>
<span class="sd">            The number of jobs to run in parallel. Defaults to `1`. `-1` means using all processors.</span>
<span class="sd">        roll_size</span>
<span class="sd">            For self-consuming predictions, i.e. `n &gt; self.output_chunk_length`, determines how many</span>
<span class="sd">            outputs of the model are fed back into it at every iteration of feeding the predicted target</span>
<span class="sd">            (and optionally future covariates) back into the model. If this parameter is not provided,</span>
<span class="sd">            it will be set `self.output_chunk_length` by default.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from a probabilistic model. Should be left set to 1</span>
<span class="sd">            for deterministic models.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Sequence[TimeSeries]</span>
<span class="sd">            Returns one or more forecasts for time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_inference_dataset_type</span><span class="p">(</span><span class="n">input_series_dataset</span><span class="p">)</span>

        <span class="c1"># check that covariates and dimensions are matching what we had during training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_predict_sample</span><span class="p">(</span><span class="n">input_series_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">roll_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roll_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">roll_size</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">,</span>
                         <span class="s1">&#39;`roll_size` must be an integer between 1 and `self.output_chunk_length`.&#39;</span><span class="p">)</span>

        <span class="c1"># check that `num_samples` is a positive integer</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">num_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;`num_samples` must be a positive integer.&#39;</span><span class="p">)</span>

        <span class="c1"># iterate through batches to produce predictions</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

        <span class="n">pred_loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">input_series_dataset</span><span class="p">,</span>
                                 <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                 <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                 <span class="n">pin_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">drop_last</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">collate_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_batch_collate_fn</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">_build_tqdm_iterator</span><span class="p">(</span><span class="n">pred_loader</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">batch_tuple</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>

                <span class="n">input_data_tuple</span><span class="p">,</span> <span class="n">batch_input_series</span> <span class="o">=</span> <span class="n">batch_tuple</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_tuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># number of individual series to be predicted in current batch</span>
                <span class="n">num_series</span> <span class="o">=</span> <span class="n">input_data_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># number of of times the input tensor should be tiled to produce predictions for multiple samples</span>
                <span class="c1"># this variable is larger than 1 only if the batch_size is at least twice as large as the number</span>
                <span class="c1"># of individual time series being predicted in current batch (`num_series`)</span>
                <span class="n">batch_sample_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">//</span> <span class="n">num_series</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">num_samples</span><span class="p">)</span>

                <span class="c1"># counts number of produced prediction samples for every series to be predicted in current batch</span>
                <span class="n">sample_count</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># repeat prediction procedure for every needed sample</span>
                <span class="n">batch_predictions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">sample_count</span> <span class="o">&lt;</span> <span class="n">num_samples</span><span class="p">:</span>

                    <span class="c1"># make sure we don&#39;t produce too many samples</span>
                    <span class="k">if</span> <span class="n">sample_count</span> <span class="o">+</span> <span class="n">batch_sample_size</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">:</span>
                        <span class="n">batch_sample_size</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">-</span> <span class="n">sample_count</span>

                    <span class="c1"># stack multiple copies of the tensors to produce probabilistic forecasts</span>
                    <span class="n">input_data_tuple_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_tiling</span><span class="p">(</span><span class="n">input_data_tuple</span><span class="p">,</span> <span class="n">batch_sample_size</span><span class="p">)</span>

                    <span class="c1"># get predictions for 1 whole batch (can include predictions of multiple series</span>
                    <span class="c1"># and for multiple samples if a probabilistic forecast is produced)</span>
                    <span class="n">batch_prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_batch_prediction</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">input_data_tuple_samples</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">)</span>

                    <span class="c1"># reshape from 3d tensor (num_series x batch_sample_size, ...)</span>
                    <span class="c1"># into 4d tensor (batch_sample_size, num_series, ...), where dim 0 represents the samples</span>
                    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">batch_prediction</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">batch_prediction</span> <span class="o">=</span> <span class="n">batch_prediction</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">batch_sample_size</span><span class="p">,</span> <span class="n">num_series</span><span class="p">,)</span> <span class="o">+</span> <span class="n">out_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="c1"># save all predictions and update the `sample_count` variable</span>
                    <span class="n">batch_predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_prediction</span><span class="p">)</span>
                    <span class="n">sample_count</span> <span class="o">+=</span> <span class="n">batch_sample_size</span>

                <span class="c1"># concatenate the batch of samples, to form num_samples samples</span>
                <span class="n">batch_predictions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">batch_predictions</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">batch_predictions</span> <span class="o">=</span> <span class="n">batch_predictions</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

                <span class="c1"># create `TimeSeries` objects from prediction tensors</span>
                <span class="n">ts_forecasts</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_forecast_series</span><span class="p">)(</span>
                        <span class="p">[</span><span class="n">batch_prediction</span><span class="p">[</span><span class="n">batch_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">batch_prediction</span> <span class="ow">in</span> <span class="n">batch_predictions</span><span class="p">],</span> <span class="n">input_series</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">input_series</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_input_series</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="n">predictions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ts_forecasts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">predictions</span>

    <span class="k">def</span> <span class="nf">_sample_tiling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data_tuple</span><span class="p">,</span> <span class="n">batch_sample_size</span><span class="p">):</span>
        <span class="n">tiled_input_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">input_data_tuple</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tensor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tiled_input_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="n">batch_sample_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tiled_input_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tiled_input_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">untrained_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_untrained_model</span><span class="p">(</span><span class="n">_get_untrained_models_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_prediction_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the first predicted within the output of self.model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">train_loader</span><span class="p">:</span> <span class="n">DataLoader</span><span class="p">,</span>
               <span class="n">val_loader</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataLoader</span><span class="p">],</span>
               <span class="n">tb_writer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SummaryWriter</span><span class="p">],</span>
               <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
               <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
               <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the actual training</span>
<span class="sd">        :param train_loader: the training data loader feeding the training data and targets</span>
<span class="sd">        :param val_loader: optionally, a validation set loader</span>
<span class="sd">        :param tb_writer: optionally, a TensorBoard writer</span>
<span class="sd">        :param epochs: value &gt;0 means we&#39;re retraining model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">best_loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="n">iterator</span> <span class="o">=</span> <span class="n">_build_tqdm_iterator</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span> <span class="o">+</span> <span class="n">epochs</span><span class="p">),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">train_batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
                <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_train_output</span><span class="p">(</span><span class="n">train_batch</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">train_batch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># By convention target is always the last element returned by datasets</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
                <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">tb_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
                    <span class="c1"># if the param doesn&#39;t require gradient, then param.grad = None and param.grad.data will crash</span>
                    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
                        <span class="n">tb_writer</span><span class="o">.</span><span class="n">add_histogram</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;/gradients&#39;</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">epoch</span><span class="p">)</span>

                <span class="n">tb_writer</span><span class="o">.</span><span class="n">add_scalar</span><span class="p">(</span><span class="s2">&quot;training/loss&quot;</span><span class="p">,</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="p">(</span><span class="n">batch_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">epoch</span><span class="p">)</span>
                <span class="n">tb_writer</span><span class="o">.</span><span class="n">add_scalar</span><span class="p">(</span><span class="s2">&quot;training/loss_total&quot;</span><span class="p">,</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="p">(</span><span class="n">batch_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">epoch</span><span class="p">)</span>
                <span class="n">tb_writer</span><span class="o">.</span><span class="n">add_scalar</span><span class="p">(</span><span class="s2">&quot;training/learning_rate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_learning_rate</span><span class="p">(),</span> <span class="n">epoch</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span> <span class="o">=</span> <span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_model</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">_get_checkpoint_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">),</span> <span class="n">epoch</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_epochs_val_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">training_loss</span> <span class="o">=</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_loader</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val_loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">validation_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_validation_loss</span><span class="p">(</span><span class="n">val_loader</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">tb_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">tb_writer</span><span class="o">.</span><span class="n">add_scalar</span><span class="p">(</span><span class="s2">&quot;validation/loss_total&quot;</span><span class="p">,</span> <span class="n">validation_loss</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">validation_loss</span> <span class="o">&lt;</span> <span class="n">best_loss</span><span class="p">:</span>
                        <span class="n">best_loss</span> <span class="o">=</span> <span class="n">validation_loss</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_save_model</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">_get_checkpoint_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">),</span> <span class="n">epoch</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training loss: </span><span class="si">{:.4f}</span><span class="s2">, validation loss: </span><span class="si">{:.4f}</span><span class="s2">, best val loss: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span>
                              <span class="nb">format</span><span class="p">(</span><span class="n">training_loss</span><span class="p">,</span> <span class="n">validation_loss</span><span class="p">,</span> <span class="n">best_loss</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training loss: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">training_loss</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_produce_predict_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evaluate_validation_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val_loader</span><span class="p">:</span> <span class="n">DataLoader</span><span class="p">):</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">val_batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val_loader</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_train_output</span><span class="p">(</span><span class="n">val_batch</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">val_batch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="n">validation_loss</span> <span class="o">=</span> <span class="n">total_loss</span> <span class="o">/</span> <span class="p">(</span><span class="n">batch_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">validation_loss</span>

    <span class="k">def</span> <span class="nf">_save_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">is_best</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                    <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the whole torch model object to a file</span>

<span class="sd">        :param is_best: whether the model we&#39;re currently saving is the best (on validation set)</span>
<span class="sd">        :param folder:</span>
<span class="sd">        :param epoch:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">checklist</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;checkpoint_*&quot;</span><span class="p">))</span>
        <span class="n">checklist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">checklist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;checkpoint_</span><span class="si">{0}</span><span class="s1">.pth.tar&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">checklist</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="c1"># remove older files</span>
            <span class="k">for</span> <span class="n">chkpt</span> <span class="ow">in</span> <span class="n">checklist</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">chkpt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_best</span><span class="p">:</span>
            <span class="n">best_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s1">&#39;model_best_</span><span class="si">{0}</span><span class="s1">.pth.tar&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">best_name</span><span class="p">)</span>
            <span class="n">checklist</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s2">&quot;model_best_*&quot;</span><span class="p">))</span>
            <span class="n">checklist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">checklist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">checklist</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># remove older files</span>
                <span class="k">for</span> <span class="n">chkpt</span> <span class="ow">in</span> <span class="n">checklist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">chkpt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_untrained_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s1">&#39;model.pth.tar&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_untrained_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s1">&#39;model.pth.tar&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_prepare_tensorboard_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">runs_folder</span> <span class="o">=</span> <span class="n">_get_runs_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_tensorboard</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tb_writer</span> <span class="o">=</span> <span class="n">SummaryWriter</span><span class="p">(</span><span class="n">runs_folder</span><span class="p">,</span> <span class="n">purge_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_epochs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tb_writer</span> <span class="o">=</span> <span class="n">SummaryWriter</span><span class="p">(</span><span class="n">runs_folder</span><span class="p">)</span>
                <span class="c1"># TODO: implement an abstract method _get_input_dims() which returns input dimensions for</span>
                <span class="c1"># TODO: eahc model type. Then we can restore tensorboard graphs.</span>
                <span class="c1"># dummy_input = torch.empty(self.batch_size, self.input_chunk_length, self.input_dim).to(self.device)</span>
                <span class="c1"># tb_writer.add_graph(self.model, dummy_input)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tb_writer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">tb_writer</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_from_checkpoint</span><span class="p">(</span><span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="n">work_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">best</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TorchForecastingModel&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the model from the given checkpoint.</span>
<span class="sd">        if file is not given, will try to restore the most recent checkpoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_name</span>
<span class="sd">            The name of the model (used to retrieve the checkpoints folder&#39;s name).</span>
<span class="sd">        work_dir</span>
<span class="sd">            Working directory (containing the checkpoints folder). Defaults to current working directory.</span>
<span class="sd">        filename</span>
<span class="sd">            The name of the checkpoint file. If not specified, use the most recent one.</span>
<span class="sd">        best</span>
<span class="sd">            If set, will retrieve the best model (according to validation loss) instead of the most recent one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TorchForecastingModel</span>
<span class="sd">            The corresponding trained `TorchForecastingModel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">work_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">work_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">DEFAULT_DARTS_FOLDER</span><span class="p">)</span>

        <span class="n">checkpoint_dir</span> <span class="o">=</span> <span class="n">_get_checkpoint_folder</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">model_name</span><span class="p">)</span>

        <span class="c1"># if filename is none, find most recent file in savepath that is a checkpoint</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">checkpoint_dir</span><span class="p">,</span> <span class="s2">&quot;model_best_*&quot;</span> <span class="k">if</span> <span class="n">best</span> <span class="k">else</span> <span class="s2">&quot;checkpoint_*&quot;</span><span class="p">)</span>
            <span class="n">checklist</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">checklist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;There is no file matching prefix </span><span class="si">{}</span><span class="s1"> in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                          <span class="s2">&quot;model_best_*&quot;</span> <span class="k">if</span> <span class="n">best</span> <span class="k">else</span> <span class="s2">&quot;checkpoint_*&quot;</span><span class="p">,</span> <span class="n">checkpoint_dir</span><span class="p">)),</span>
                          <span class="n">logger</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">checklist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getctime</span><span class="p">)</span>  <span class="c1"># latest file TODO: check case where no files match</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">full_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">checkpoint_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_get_best_torch_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">is_cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_learning_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">param_groups</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TorchParametricProbabilisticForecastingModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LikelihoodModel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pytorch Parametric Probabilistic Forecasting Model.</span>

<span class="sd">        This is a base class for pytroch parametric probabilistic models. &quot;Parametric&quot;</span>
<span class="sd">        means that these models are based on some predefined parametric distribution, say Gaussian.</span>
<span class="sd">        Make sure that subclasses contain the *likelihood* parameter in __init__ method</span>
<span class="sd">        and it is passed to the superclass via calling super().__init__. If the likelihood is not</span>
<span class="sd">        provided, the model is considered as deterministic.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        likelihood</span>
<span class="sd">            The likelihood model to be used for probabilistic forecasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="n">likelihood</span>

    <span class="k">def</span> <span class="nf">_is_probabilistic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_produce_predict_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method has to be implemented by all children.</span>

<span class="sd">        TODO: rename parameter as it shadows input name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_raise_if_wrong_type</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;expected type </span><span class="si">{}</span><span class="s1">, got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">):</span>
    <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">),</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exp_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_cat_with_optional</span><span class="p">(</span><span class="n">tsr1</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tsr2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">tsr2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tsr1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># dimensions are (batch, length, width), we concatenate along the widths.</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">tsr1</span><span class="p">,</span> <span class="n">tsr2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Below we define the 5 torch model types:</span>
<span class="sd">    * PastCovariatesTorchModel</span>
<span class="sd">    * FutureCovariatesTorchModel</span>
<span class="sd">    * DualCovariatesTorchModel</span>
<span class="sd">    * MixedCovariatesTorchModel</span>
<span class="sd">    * SplitCovariatesTorchModel</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># TODO: there&#39;s a lot of repetition below... is there a cleaner way to do this in Python- Using eg generics or something</span>


<span class="k">def</span> <span class="nf">_basic_compare_sample</span><span class="p">(</span><span class="n">train_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For all models relying on one type of covariates only (Past, Future, Dual), we can rely on the fact</span>
<span class="sd">    that training/inference datasets have target and a covariate in first and second position to do the checks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tgt_train</span><span class="p">,</span> <span class="n">cov_train</span> <span class="o">=</span> <span class="n">train_sample</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tgt_pred</span><span class="p">,</span> <span class="n">cov_pred</span> <span class="o">=</span> <span class="n">predict_sample</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">raise_if_not</span><span class="p">(</span><span class="n">tgt_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tgt_pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                 <span class="s1">&#39;The provided target has a dimension (width) that does not match the dimension &#39;</span>
                 <span class="s1">&#39;of the target this model has been trained on.&#39;</span><span class="p">)</span>
    <span class="n">raise_if</span><span class="p">(</span><span class="n">cov_train</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cov_pred</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
             <span class="s1">&#39;This model has been trained with covariates; some covariates of matching dimensionality are needed &#39;</span>
             <span class="s1">&#39;for prediction.&#39;</span><span class="p">)</span>
    <span class="n">raise_if</span><span class="p">(</span><span class="n">cov_train</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cov_pred</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
             <span class="s1">&#39;This model has been trained without covariates. No covariates should be provided for prediction.&#39;</span><span class="p">)</span>
    <span class="n">raise_if</span><span class="p">(</span><span class="n">cov_train</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cov_pred</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
             <span class="n">cov_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cov_pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
             <span class="s1">&#39;The provided covariates must have dimensionality matching that of the covariates used for training &#39;</span>
             <span class="s1">&#39;the model.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PastCovariatesTorchModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">PastCovariatesTrainingDataset</span><span class="p">:</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">future_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Specified future_covariates for a PastCovariatesModel (only past_covariates are expected).&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PastCovariatesSequentialDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                               <span class="n">covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                               <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                               <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">PastCovariatesInferenceDataset</span><span class="p">:</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">future_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Specified future_covariates for a PastCovariatesModel (only past_covariates are expected).&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PastCovariatesInferenceDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                              <span class="n">covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                              <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                              <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                              <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">PastCovariatesTrainingDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">inference_dataset</span><span class="p">,</span> <span class="n">PastCovariatesInferenceDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="n">_basic_compare_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">future_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Some future_covariates have been provided to a PastCovariates model. These models &#39;</span>
                     <span class="s1">&#39;support only past_covariates.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_produce_train_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="n">past_target</span><span class="p">,</span> <span class="n">past_covariate</span> <span class="o">=</span> <span class="n">input_batch</span>
        <span class="c1"># Currently all our PastCovariates models require past target and covariates concatenated</span>
        <span class="n">inpt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">past_target</span><span class="p">,</span> <span class="n">past_covariate</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">past_covariate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">past_target</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">inpt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">past_target</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">cov_future</span> <span class="o">=</span> <span class="n">input_batch</span>
        <span class="n">input_series</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">past_target</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">past_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">past_target</span>

        <span class="n">batch_prediction</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># TODO: remove this &quot;first_prediction_index&quot; and move it into the models that need it</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_predict_output</span><span class="p">(</span><span class="n">input_series</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_prediction_index</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="n">batch_prediction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">roll_size</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">prediction_length</span> <span class="o">=</span> <span class="n">roll_size</span>

        <span class="k">while</span> <span class="n">prediction_length</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>

            <span class="c1"># roll over input series to contain latest target and covariate</span>
            <span class="n">input_series</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">input_series</span><span class="p">,</span> <span class="o">-</span><span class="n">roll_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># update target input to include next `roll_size` predictions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span> <span class="o">&gt;=</span> <span class="n">roll_size</span><span class="p">:</span>
                <span class="n">input_series</span><span class="p">[:,</span> <span class="o">-</span><span class="n">roll_size</span><span class="p">:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">roll_size</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_series</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># update covariates to include next `roll_size` predictions into the future</span>
            <span class="k">if</span> <span class="n">cov_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span> <span class="o">&gt;=</span> <span class="n">roll_size</span><span class="p">:</span>
                <span class="n">input_series</span><span class="p">[:,</span> <span class="o">-</span><span class="n">roll_size</span><span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cov_future</span><span class="p">[:,</span> <span class="n">prediction_length</span> <span class="o">-</span> <span class="n">roll_size</span><span class="p">:</span><span class="n">prediction_length</span><span class="p">,</span> <span class="p">:]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">cov_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_series</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cov_future</span><span class="p">[:,</span> <span class="n">prediction_length</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">:</span><span class="n">prediction_length</span><span class="p">,</span> <span class="p">:]</span>
                <span class="p">)</span>

            <span class="c1"># take only last part of the output sequence where needed</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_predict_output</span><span class="p">(</span><span class="n">input_series</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_prediction_index</span><span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># update predictions depending on how many data points have been predicted</span>
            <span class="k">if</span> <span class="n">prediction_length</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span> <span class="o">-</span> <span class="n">roll_size</span><span class="p">:</span>
                <span class="n">batch_prediction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">roll_size</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">prediction_length</span> <span class="o">+=</span> <span class="n">roll_size</span>
            <span class="k">elif</span> <span class="n">prediction_length</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">:</span>
                <span class="c1"># if we produce have `n - output_chunk_length &lt; #predictions &lt; n` we want to only use</span>
                <span class="c1"># the predictions and covariates necessary to exactly reach `n - output_chunk_length`,</span>
                <span class="c1"># so that the final forecast produces exactly the right number of predictions to reach `n`</span>
                <span class="n">spillover_prediction_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">prediction_length</span> <span class="o">+</span> <span class="n">roll_size</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>
                <span class="n">roll_size</span> <span class="o">-=</span> <span class="n">spillover_prediction_length</span>
                <span class="n">batch_prediction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[:,</span> <span class="p">:</span><span class="n">roll_size</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">prediction_length</span> <span class="o">+=</span> <span class="n">roll_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">batch_prediction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                <span class="n">prediction_length</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span>

        <span class="c1"># bring predictions into desired format and drop unnecessary values</span>
        <span class="n">batch_prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">batch_prediction</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">batch_prediction</span> <span class="o">=</span> <span class="n">batch_prediction</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">batch_prediction</span>


<span class="k">class</span> <span class="nc">FutureCovariatesTorchModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">FutureCovariatesTrainingDataset</span><span class="p">:</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">past_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Specified past_covariates for a FutureCovariatesModel (only future_covariates are expected).&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FutureCovariatesSequentialDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                 <span class="n">covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                                 <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                                 <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">FutureCovariatesInferenceDataset</span><span class="p">:</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">past_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Specified past_covariates for a FutureCovariatesModel (only future_covariates are expected).&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FutureCovariatesInferenceDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">FutureCovariatesTrainingDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">inference_dataset</span><span class="p">,</span> <span class="n">FutureCovariatesInferenceDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="n">_basic_compare_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">past_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Some past_covariates have been provided to a PastCovariates model. These models &#39;</span>
                     <span class="s1">&#39;support only future_covariates.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;TBD: Darts doesn&#39;t contain such a model yet.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DualCovariatesTorchModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">DualCovariatesTrainingDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">DualCovariatesSequentialDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                               <span class="n">covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                               <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                               <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">DualCovariatesInferenceDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">DualCovariatesInferenceDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                              <span class="n">covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                              <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                              <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                              <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">DualCovariatesTrainingDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">inference_dataset</span><span class="p">,</span> <span class="n">DualCovariatesInferenceDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="n">_basic_compare_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_sample</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">past_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;Some past_covariates have been provided to a PastCovariates model. These models &#39;</span>
                     <span class="s1">&#39;support only future_covariates.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;TBD: The only DualCovariatesModel is an RNN with a specific implementation.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MixedCovariatesTorchModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">MixedCovariatesTrainingDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">MixedCovariatesSequentialDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                                <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                                <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                                <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">MixedCovariatesInferenceDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">MixedCovariatesInferenceDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                               <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                               <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                               <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                               <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                               <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">MixedCovariatesTrainingDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">inference_dataset</span><span class="p">,</span> <span class="n">MixedCovariatesInferenceDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="c1"># TODO: we have to check both past and future covariates</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="c1"># both covariates are supported; do nothing</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;TBD: Darts doesn&#39;t contain such a model yet.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SplitCovariatesTorchModel</span><span class="p">(</span><span class="n">TorchForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_build_train_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                             <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                             <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">SplitCovariatesTrainingDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">SplitCovariatesSequentialDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                                <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                                <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                                <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                                <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_inference_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
                                 <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
                                 <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">SplitCovariatesInferenceDataset</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">SplitCovariatesInferenceDataset</span><span class="p">(</span><span class="n">target_series</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                               <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                                               <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                                               <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                               <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                                               <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_train_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">:</span> <span class="n">TrainingDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">SplitCovariatesTrainingDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_inference_dataset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inference_dataset</span><span class="p">:</span> <span class="n">InferenceDataset</span><span class="p">):</span>
        <span class="n">_raise_if_wrong_type</span><span class="p">(</span><span class="n">inference_dataset</span><span class="p">,</span> <span class="n">SplitCovariatesInferenceDataset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify_past_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">):</span>
        <span class="c1"># both covariates are supported; do nothing</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_verify_predict_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predict_sample</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="c1"># TODO: we have to check both past and future covariates</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_batch_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">input_batch</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">roll_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;TBD: Darts doesn&#39;t contain such a model yet.&quot;</span><span class="p">)</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../../_static/js/index.3da636dd464baa7582d2.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2021, Unit8 SA.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>