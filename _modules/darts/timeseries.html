
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.timeseries &#8212; darts  documentation</title>
    
  <link rel="stylesheet" href="../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../index.html">
    
      <img src="../../_static/darts-logo-trim.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../README.html">Home</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../generated_api/darts.html">API Reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../examples.html">Examples</a>
        </li>
        
        
      </ul>


      <form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/unit8co/darts" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
          <li class="nav-item">
            <a class="nav-link" href="https://twitter.com/unit8co" target="_blank" rel="noopener">
              <span><i class="fab fa-twitter-square"></i></span>
            </a>
          </li>
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.timeseries</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Timeseries</span>
<span class="sd">----------</span>

<span class="sd">`TimeSeries` is the main class in `darts`. It represents a univariate or multivariate time series.</span>
<span class="sd">It can represent a stochastic time series by storing several samples (trajectories).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>

<span class="kn">from</span> <span class="nn">.logging</span> <span class="kn">import</span> <span class="n">raise_log</span><span class="p">,</span> <span class="n">raise_if_not</span><span class="p">,</span> <span class="n">raise_if</span><span class="p">,</span> <span class="n">get_logger</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># dimension names in the DataArray</span>
<span class="c1"># the &quot;time&quot; one can be different, if it has a name in the underlying Series/DataFrame.</span>
<span class="n">DIMS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;component&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="TimeSeries"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries">[docs]</a><span class="k">class</span> <span class="nc">TimeSeries</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around a (well formed) DataArray. Use the static factory methods to build instances unless</span>
<span class="sd">        you know what you are doing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">),</span> <span class="s1">&#39;Data must be provided as an xarray DataArray instance. &#39;</span>
                                                   <span class="s1">&#39;If you need to create a TimeSeries from another type &#39;</span>
                                                   <span class="s1">&#39;(e.g. a DataFrame), look at TimeSeries factory methods &#39;</span>
                                                   <span class="s1">&#39;(e.g. TimeSeries.from_dataframe(), &#39;</span>
                                                   <span class="s1">&#39;TimeSeries.from_xarray(), TimeSeries.from_values()&#39;</span>
                                                   <span class="s1">&#39;TimeSeries.from_times_and_values(), etc...).&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;The time series array must not be empty.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;TimeSeries require DataArray of dimensionality 3 (</span><span class="si">{}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DIMS</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># Ideally values should be np.float, otherwise certain functionalities like diff()</span>
        <span class="c1"># relying on np.nan (which is a float) won&#39;t work very properly.</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">),</span> <span class="s1">&#39;The time series must contain numeric values only.&#39;</span><span class="p">,</span>
                     <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;TimeSeries is using a numeric type different from np.float. Not all functionalities &#39;</span>
                        <span class="s1">&#39;may work properly. It is recommended casting your data to floating point numbers before &#39;</span>
                        <span class="s1">&#39;using TimeSeries.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="c1"># The first dimension represents the time and may be named differently.</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The last two dimensions of the DataArray must be named </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># check that columns/component names are unique</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">),</span>
                     <span class="s1">&#39;The components (columns) names must be unique. Provided: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">components</span><span class="p">),</span>
                     <span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># how the time dimension is named</span>

        <span class="c1"># The following sorting returns a copy, which we are relying on.</span>
        <span class="c1"># As of xarray 0.18.2, this sorting discards the freq of the index for some reason</span>
        <span class="c1"># https://github.com/pydata/xarray/issues/5466</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The time dimension of the DataArray must be indexed either with a DatetimeIndex,&#39;</span>
                                 <span class="s1">&#39;or with an Int64Index (this can include a RangeIndex).&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">freq_tmp</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span>  <span class="c1"># store original freq (see bug of sortby() above).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_tmp</span> <span class="k">if</span> <span class="n">freq_tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                                         <span class="n">to_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">inferred_freq</span><span class="p">))</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="s1">&#39;The time index of the provided DataArray is missing the freq attribute, and the &#39;</span>
                     <span class="s1">&#39;frequency cannot be inferred.&#39;</span><span class="p">,</span>
                     <span class="n">logger</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="o">.</span><span class="n">freqstr</span>

            <span class="c1"># reset freq inside the xarray index (see bug of sortby() above).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

            <span class="c1"># We have to check manually if the index is complete. Another way could be to rely</span>
            <span class="c1"># on `inferred_freq` being present, but this fails for series of length &lt; 3.</span>
            <span class="n">is_index_complete</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                                                  <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

            <span class="n">raise_if_not</span><span class="p">(</span><span class="n">is_index_complete</span><span class="p">,</span> <span class="s1">&#39;Not all timestamps seem to be present in the time index. Does &#39;</span>
                                            <span class="s1">&#39;the series contain holes? If you are using a factory method, &#39;</span>
                                            <span class="s1">&#39;try specifying `fill_missing_dates=True` &#39;</span>
                                            <span class="s1">&#39;or specify the `freq` parameter.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Factory Methods</span>
<span class="sd">    ===============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.from_xarray"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_xarray">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_xarray</span><span class="p">(</span><span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
                    <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a TimeSeries instance built from an xarray DataArray.</span>
<span class="sd">        The dimensions of the DataArray have to be (time, component, sample), in this order. The time</span>
<span class="sd">        dimension can have an arbitrary name, but component and sample must be named &quot;component&quot; and &quot;sample&quot;,</span>
<span class="sd">        respectively.</span>

<span class="sd">        The first dimension (time), and second dimension (component) must be indexed (i.e., have coordinates).</span>
<span class="sd">        The time must be indexed either with a pandas DatetimeIndex or a pandas Int64Index. If a DatetimeIndex is</span>
<span class="sd">        used, it is better if it has no holes; although setting `fill_missing_dates` can in some cases solve these</span>
<span class="sd">        issues (filling holes with NaN) at a performance cost.</span>

<span class="sd">        If two components have the same name or are not strings, this method will disambiguate the components</span>
<span class="sd">        names by appending a suffix of the form &quot;&lt;name&gt;_N&quot; to the N-th column with name &quot;name&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa</span>
<span class="sd">            The xarray DataArray</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates with NaN values. This requires</span>
<span class="sd">            either a provided `freq` or the possibility to infer the frequency from the provided timestamps.</span>
<span class="sd">            Inferring the frequency and resampling the data can induce a significant performance overhead.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DataFrame. This is useful in order to fill</span>
<span class="sd">            in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate or multivariate deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># optionally fill missing dates; do it only when there is a DatetimeIndex (and not a Int64Index)</span>
        <span class="k">if</span> <span class="n">fill_missing_dates</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">sorted_xa</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">freq</span><span class="p">:</span>
                <span class="c1"># FIXME: This is taking long, especially on longer series</span>
                <span class="c1"># FIXME: both constructing observed_frequencies, as well as resampling the DataArray are taking long</span>
                <span class="c1"># FIXME: can we do better?</span>
                <span class="n">samples_size</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">observed_frequencies</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">time_index</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">x</span> <span class="o">+</span> <span class="n">samples_size</span><span class="p">]</span><span class="o">.</span><span class="n">inferred_freq</span>
                    <span class="k">for</span> <span class="n">x</span>
                    <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span> <span class="o">-</span> <span class="n">samples_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

                <span class="n">observed_frequencies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">,</span> <span class="n">observed_frequencies</span><span class="p">))</span>

                <span class="n">raise_if_not</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">observed_frequencies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;Could not infer explicit frequency. Observed frequencies: &quot;</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;none&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_frequencies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">observed_frequencies</span><span class="p">))</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;. Is Series too short (n=</span><span class="si">{}</span><span class="s2">)?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">samples_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_frequencies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                       <span class="k">else</span> <span class="s1">&#39;.&#39;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">)</span>

                <span class="n">freq</span> <span class="o">=</span> <span class="n">observed_frequencies</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="n">xa_</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">freq</span><span class="p">})</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The provided index does not have a freq; using the provided freq</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">freq</span><span class="p">})</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa</span>

        <span class="c1"># clean components (columns) names if needed (if names are not unique, or not strings)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]):</span>

            <span class="k">def</span> <span class="nf">_clean_component_list</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
                <span class="c1"># return a list of string containing column names</span>
                <span class="c1"># make each column name unique in case some columns have the same names</span>
                <span class="n">clist</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

                <span class="c1"># convert everything to string if needed</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clist</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

                <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">has_duplicate</span><span class="p">:</span>
                    <span class="c1"># we may have to loop several times (e.g. we could have columns [&quot;0&quot;, &quot;0_1&quot;, &quot;0&quot;] and not</span>
                    <span class="c1"># noticing when renaming the last &quot;0&quot; into &quot;0_1&quot; that &quot;0_1&quot; already exists...)</span>
                    <span class="n">name_to_occurence</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clist</span><span class="p">):</span>
                        <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">clist</span>

            <span class="n">time_index_name</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">columns_list</span> <span class="o">=</span> <span class="n">_clean_component_list</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

            <span class="c1"># TODO: is there a way to just update the component index without re-creating a new DataArray?</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">xa_</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                               <span class="n">dims</span><span class="o">=</span><span class="n">xa_</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                               <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">time_index_name</span><span class="p">:</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_index_name</span><span class="p">),</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">columns_list</span><span class="p">})</span>

        <span class="c1"># We cast the array to float</span>
        <span class="c1"># TODO: is astype() always copying? (might be slightly inefficient if array is already float)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">xa_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.from_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_dataframe">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                       <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deterministic TimeSeries instance built from a selection of columns of a DataFrame.</span>
<span class="sd">        One column (or the DataFrame index) has to represent the time,</span>
<span class="sd">        and a list of columns `value_cols` has to represent the values for this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df</span>
<span class="sd">            The DataFrame</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex.</span>
<span class="sd">            If not set, the DataFrame index will be used. In this case the DataFrame must contain an index that is</span>
<span class="sd">            either a pandas DatetimeIndex or a pandas Int64Index (incl. RangeIndex). If a DatetimeIndex is</span>
<span class="sd">            used, it is better if it has no holes; although setting `fill_missing_dates` can in some cases solve these</span>
<span class="sd">            issues (filling holes with NaN) at a performance cost.</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the DataFrame. If set to</span>
<span class="sd">            `None`, the whole DataFrame will be used.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates with NaN values. This requires</span>
<span class="sd">            either a provided `freq` or the possibility to infer the frequency from the provided timestamps.</span>
<span class="sd">            Inferring the frequency and resampling the data can induce a significant performance overhead.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DataFrame. This is useful in order to fill</span>
<span class="sd">            in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate or multivariate deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get values</span>
        <span class="k">if</span> <span class="n">value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">time_col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">value_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>

        <span class="c1"># get time index</span>
        <span class="k">if</span> <span class="n">time_col</span><span class="p">:</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">),</span>
                         <span class="s1">&#39;If time_col is not specified, the DataFrame must be indexed either with&#39;</span>
                         <span class="s1">&#39;a DatetimeIndex, or with a Int64Index (incl. RangeIndex).&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">time_index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">series_df</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                          <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
                          <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">series_df</span><span class="o">.</span><span class="n">columns</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">xa</span><span class="o">=</span><span class="n">xa</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_series">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_series</span><span class="p">(</span><span class="n">pd_series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
                    <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a univariate and deterministic TimeSeries built from a pandas Series.</span>

<span class="sd">        The series must contain an index that is</span>
<span class="sd">        either a pandas DatetimeIndex or a pandas Int64Index (incl. RangeIndex). If a DatetimeIndex is</span>
<span class="sd">        used, it is better if it has no holes; although setting `fill_missing_dates` can in some cases solve these</span>
<span class="sd">        issues (filling holes with NaN) at a performance cost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pd_series</span>
<span class="sd">            The pandas Series instance.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates with NaN values. This requires</span>
<span class="sd">            either a provided `freq` or the possibility to infer the frequency from the provided timestamps.</span>
<span class="sd">            Inferring the frequency and resampling the data can induce a significant performance overhead.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DataFrame. This is useful in order to fill</span>
<span class="sd">            in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate and deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pd_series</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                                         <span class="n">time_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">value_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
                                         <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_times_and_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_times_and_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_times_and_values</span><span class="p">(</span><span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">],</span>
                              <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                              <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a TimeSeries built from an index and value array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            A `pandas.DateTimeIndex` or `pandas.Int64Index` (or `pandas.RangeIndex`) representing the time axis</span>
<span class="sd">            for the time series. If a DatetimeIndex is</span>
<span class="sd">            used, it is better if it has no holes; although setting `fill_missing_dates` can in some cases solve these</span>
<span class="sd">            issues (filling holes with NaN) at a performance cost.</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates with NaN values. This requires</span>
<span class="sd">            either a provided `freq` or the possibility to infer the frequency from the provided timestamps.</span>
<span class="sd">            Inferring the frequency and resampling the data can induce a significant performance overhead.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DataFrame. This is useful in order to fill</span>
<span class="sd">            in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">        columns</span>
<span class="sd">            Columns to be used by the underlying pandas DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">),</span>
                     <span class="s1">&#39;the `times` argument must be a Int64Index (or RangeIndex), or a DateTimeIndex. Use &#39;</span>
                     <span class="s1">&#39;TimeSeries.from_values() if you want to use an automatic RangeIndex.&#39;</span><span class="p">)</span>

        <span class="n">times_name</span> <span class="o">=</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">times</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="n">times</span><span class="o">.</span><span class="n">name</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">times_name</span><span class="p">:</span> <span class="n">times</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">columns</span>

        <span class="n">xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                          <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">times_name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
                          <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">xa</span><span class="o">=</span><span class="n">xa</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a TimeSeries built from an array of values.</span>
<span class="sd">        The series will have an integer index (Int64Index).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates with NaN values. This requires</span>
<span class="sd">            either a provided `freq` or the possibility to infer the frequency from the provided timestamps.</span>
<span class="sd">            Inferring the frequency and resampling the data can induce a significant performance overhead.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DataFrame. This is useful in order to fill</span>
<span class="sd">            in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">        columns</span>
<span class="sd">            Columns to be used by the underlying pandas DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">values_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">values</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">time_index</span><span class="p">,</span>
                                                <span class="n">values</span><span class="o">=</span><span class="n">values_</span><span class="p">,</span>
                                                <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
                                                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_json">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the JSON String representation of a `TimeSeries` object (produced using `TimeSeries.to_json()`)</span>
<span class="sd">        into a `TimeSeries` object</span>

<span class="sd">        At the moment this only supports deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_str</span>
<span class="sd">            The JSON String to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The time series object converted from the JSON String</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;split&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Properties</span>
<span class="sd">    ==========</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_probabilistic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The names of the components (equivalent to DataFrame columns) as a Pandas Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as `components` property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pd.DatetimeIndex, pd.Int64Index]</span>
<span class="sd">            The time index of this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_datetime_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether this series is indexed with a DatetimeIndex (otherwise it is indexed with an Int64Index)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_range_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether this series is indexed with an Int64Index (otherwise it is indexed with a DatetimeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timedelta, int]</span>
<span class="sd">            The duration of this time series; as a Timedelta if the series is indexed by a Datetimeindex,</span>
<span class="sd">            and int otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Some asserts</span>
<span class="sd">    =============</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: put at the bottom</span>

    <span class="k">def</span> <span class="nf">_assert_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Only univariate TimeSeries instances support this method&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Only deterministic TimeSeries (with 1 sample) instances support this method&#39;</span><span class="p">),</span>
                      <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Only non-deterministic TimeSeries (with more than 1 samples) &#39;</span>
                                     <span class="s1">&#39;instances support this method&#39;</span><span class="p">),</span>
                      <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_raise_if_not_within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># Not that the converse doesn&#39;t apply (a time-indexed series can be called with an integer)</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                         <span class="s1">&#39;Function called with a timestamp, but series not time-indexed.&#39;</span><span class="p">,</span>
                         <span class="n">logger</span><span class="p">)</span>
            <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">is_inside</span><span class="p">,</span> <span class="s1">&#39;Timestamp must be between </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                                                                             <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()),</span>
                     <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_first_timestamp_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_last_timestamp_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export functions</span>
<span class="sd">    ================</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.data_array"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.data_array">[docs]</a>    <span class="k">def</span> <span class="nf">data_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the xarray DataArray representation of this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            The xarray DataArray underlying this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span></div>

<div class="viewcode-block" id="TimeSeries.pd_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.pd_series">[docs]</a>    <span class="k">def</span> <span class="nf">pd_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Pandas Series representation of this time series.</span>
<span class="sd">        Works only for univariate series that are deterministic (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            A Pandas Series representation of this univariate time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.pd_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.pd_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">pd_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Pandas DataFrame representation of this time series.</span>
<span class="sd">        Each of the series components will appear as a column in the DataFrame.</span>
<span class="sd">        Works only for deterministic series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the dataframe. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame representation of this time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;The pd_dataframe() method can only return DataFrames of deterministic &#39;</span>
                                     <span class="s1">&#39;time series, and this series is not deterministic (it contains several samples). &#39;</span>
                                     <span class="s1">&#39;Consider calling quantile_df() instead.&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s1">&#39;component&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="s1">&#39;component&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.quantile_df"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile_df">[docs]</a>    <span class="k">def</span> <span class="nf">quantile_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Pandas DataFrame containing the single desired quantile of each component (over the samples).</span>
<span class="sd">        Each of the series components will appear as a column in the DataFrame. The column will be named</span>
<span class="sd">        &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot; is the column name corresponding to this component, and &quot;X&quot;</span>
<span class="sd">        is the quantile value.</span>
<span class="sd">        The quantile columns represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantile</span>
<span class="sd">            The desired quantile value. The value must be represented as a fraction</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `0.5` will return a DataFrame</span>
<span class="sd">            containing the median of the (marginal) distribution of each component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame containing the desired quantile for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">quantile</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;The quantile values must be expressed as fraction (between 0 and 1 inclusive).&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># column names</span>
        <span class="n">cnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quantile</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                            <span class="n">columns</span><span class="o">=</span><span class="n">cnames</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantile_timeseries"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">quantile_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deterministic `TimeSeries` containing the single desired quantile of each component</span>
<span class="sd">        (over the samples) of this stochastic `TimeSeries`.</span>
<span class="sd">        The components in the new series are named &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot;</span>
<span class="sd">        is the column name corresponding to this component, and &quot;X&quot; is the quantile value.</span>
<span class="sd">        The quantile columns represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantile</span>
<span class="sd">            The desired quantile value. The value must be represented as a fraction</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `0.5` will return a TimeSeries</span>
<span class="sd">            containing the median of the (marginal) distribution of each component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the desired quantile for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quantile_df</span><span class="p">(</span><span class="n">quantile</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.quantiles_df"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantiles_df">[docs]</a>    <span class="k">def</span> <span class="nf">quantiles_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Pandas DataFrame containing the desired quantiles of each component (over the samples).</span>
<span class="sd">        Each of the series components will appear as a column in the DataFrame. The column will be named</span>
<span class="sd">        &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot; is the column name corresponding to this component, and &quot;X&quot;</span>
<span class="sd">        is the quantile value.</span>
<span class="sd">        The quantiles represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantiles</span>
<span class="sd">            Tuple containing the desired quantiles. The values must be represented as fractions</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `(0.1, 0.5, 0.9)` will return a DataFrame</span>
<span class="sd">            containing the 10th-percentile, median and 90th-percentile of the (marginal) distribution of each component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame containing the quantiles for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: there might be a slightly more efficient way to do it for several quantiles at once with xarray...</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">quantile_df</span><span class="p">(</span><span class="n">quantile</span><span class="p">)</span> <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="n">quantiles</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.start_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.start_time">[docs]</a>    <span class="k">def</span> <span class="nf">start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the first time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by Int64Index/RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.end_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.end_time">[docs]</a>    <span class="k">def</span> <span class="nf">end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the last time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by Int64Index/RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.first_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_value">[docs]</a>    <span class="k">def</span> <span class="nf">first_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The first value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.last_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_value">[docs]</a>    <span class="k">def</span> <span class="nf">last_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The last value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.first_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_values">[docs]</a>    <span class="k">def</span> <span class="nf">first_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The first values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.last_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_values">[docs]</a>    <span class="k">def</span> <span class="nf">last_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The last values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2-D Numpy array of dimension (time, component), containing this series&#39; values for one sample.</span>
<span class="sd">        If this series is deterministic, it contains only one sample and only `sample=0` can be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="ow">and</span> <span class="n">sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;This series contains one sample only (deterministic),&#39;</span>
                                                        <span class="s1">&#39;so only sample=0 is accepted.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.all_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.all_values">[docs]</a>    <span class="k">def</span> <span class="nf">all_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 3-D Numpy array of dimension (time, component, sample),</span>
<span class="sd">        containing this series&#39; values for all samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_values">[docs]</a>    <span class="k">def</span> <span class="nf">univariate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 1-D Numpy array of dimension (time,), containing this univariate series&#39; values for one sample.</span>
<span class="sd">        If this series is deterministic, it contains only one sample and only `sample=0` can be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series guaranteed to be univariate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">values</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Other methods</span>
<span class="sd">    =============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.gaps"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.gaps">[docs]</a>    <span class="k">def</span> <span class="nf">gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to compute and return gaps in the TimeSeries. Works only on deterministic time series (1 sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            A pandas.DataFrame containing a row for every gap (rows with all-NaN values in underlying DataFrame)</span>
<span class="sd">            in this time series. The DataFrame contains three columns that include the start and end time stamps</span>
<span class="sd">            of the gap and the integer length of the gap (in `self.freq` units if the series is indexed</span>
<span class="sd">            by a DatetimeIndex).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span>

        <span class="n">is_nan_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
        <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">gap_starts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">gap_ends</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gap_ends</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">())</span>

        <span class="n">gap_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">gap_df</span><span class="p">[</span><span class="s1">&#39;gap_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_starts</span>
        <span class="n">gap_df</span><span class="p">[</span><span class="s1">&#39;gap_end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_ends</span>

        <span class="k">def</span> <span class="nf">intvl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span>

        <span class="n">gap_df</span><span class="p">[</span><span class="s1">&#39;gap_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">intvl</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">gap_df</span></div>

<div class="viewcode-block" id="TimeSeries.copy"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this time series object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A copy of this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>  <span class="c1"># the xarray will be copied in the TimeSeries constructor</span></div>

<div class="viewcode-block" id="TimeSeries.get_index_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_index_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_index_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a point into an integer index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: `pd.Timestamp`, `float` and `int`.</span>

<span class="sd">            `pd.Timestamp` work only on series that are indexed with a `pd.DatetimeIndex`. In such cases, the returned</span>
<span class="sd">            point will be the index of this timestamp if it is present in the series time index. It it&#39;s not present</span>
<span class="sd">            in the time index, the index of the next timestamp is returned if `after=True` (if it exists in the series),</span>
<span class="sd">            otherwise the index of the previous timestamp is returned (if it exists in the series).</span>

<span class="sd">            In case of a `float`, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>

<span class="sd">            In the case of `int`, the parameter will returned as such, provided that it is in the series. Otherwise</span>
<span class="sd">            it will raise a ValueError.</span>
<span class="sd">        after</span>
<span class="sd">            If the provided pandas Timestamp is not in the time series index, whether to return the index of the</span>
<span class="sd">            next timestamp or the index of the previous one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">point</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;point (float) should be between 0.0 and 1.0.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="s2">&quot;point (int) should be a valid index in series&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                         <span class="s1">&#39;A Timestamp has been provided, but this series is not time-indexed.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`point` needs to be either `float`, `int` or `pd.Timestamp`&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">point_index</span></div>

<div class="viewcode-block" id="TimeSeries.get_timestamp_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_timestamp_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestamp_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a point into a pandas.Timestamp (if Datetime-indexed) or into an integer (if Int64-indexed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: `float`, `int` and `pandas.Timestamp`.</span>
<span class="sd">            In case of a `float`, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>
<span class="sd">            In the case of `int`, the parameter will be treated as an integer index to the time index of</span>
<span class="sd">            `series`. Will raise a ValueError if not a valid index in `series`</span>
<span class="sd">            In case of a `pandas.Timestamp`, point will be returned as is provided that the timestamp</span>
<span class="sd">            is present in the series time index, otherwise will raise a ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_split_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                  <span class="n">after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;TimeSeries&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">]:</span>

        <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="n">point_index</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)],</span> <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">):]</span>

<div class="viewcode-block" id="TimeSeries.split_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_after">[docs]</a>    <span class="k">def</span> <span class="nf">split_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;TimeSeries&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the TimeSeries in two, after a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position after</span>
<span class="sd">            which the split is performed. A pd.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pd.DatetimeIndex. In such cases, the timestamp will be contained in the first TimeSeries, but not</span>
<span class="sd">            in the second one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two time series. The first time series contains the first samples up to the `split_point`,</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.split_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_before">[docs]</a>    <span class="k">def</span> <span class="nf">split_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;TimeSeries&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the TimeSeries in two, before a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position before</span>
<span class="sd">            which the split is performed. A pd.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pd.DatetimeIndex. In such cases, the timestamp will be contained in the second TimeSeries, but not</span>
<span class="sd">            in the first one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two time series. The first time series contains the first samples up to the `split_point`,</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.drop_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_after">[docs]</a>    <span class="k">def</span> <span class="nf">drop_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops everything after the provided timestamp `ts`, included.</span>
<span class="sd">        The timestamp may not be in the TimeSeries. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, after `ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_before</span><span class="p">(</span><span class="n">split_point</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.drop_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_before">[docs]</a>    <span class="k">def</span> <span class="nf">drop_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops everything before the provided timestamp `ts`, included.</span>
<span class="sd">        The timestamp may not be in the TimeSeries. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, after `ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_after</span><span class="p">(</span><span class="n">split_point</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new TimeSeries, starting later than `start_ts` and ending before `end_ts`, inclusive on both ends.</span>
<span class="sd">        The timestamps don&#39;t have to be in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp that indicates the left cut-off.</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp that indicates the right cut-off.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with indices greater or equal than `start_ts` and smaller or equal than `end_ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">end_ts</span><span class="p">),</span> <span class="s1">&#39;The two timestamps provided to slice() have to be of the &#39;</span>
                                                     <span class="s1">&#39;same type.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span> <span class="s1">&#39;Timestamps have been provided to slice(), but the series is &#39;</span>
                                                   <span class="s1">&#39;indexed using an integer-based Int64Index.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">start_ts</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">end_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span> <span class="s1">&#39;start and end times have been provided as integers to slice(), but &#39;</span>
                                               <span class="s1">&#39;the series is indexed with a DatetimeIndex.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_after">[docs]</a>    <span class="k">def</span> <span class="nf">slice_n_points_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new TimeSeries, starting a `start_ts` and having at most `n` points.</span>

<span class="sd">        The provided timestamps will be included in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with length at most `n`, starting at `start_ts`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;n should be a positive integer.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">start_ts</span><span class="p">:</span><span class="n">start_ts</span><span class="o">+</span><span class="n">n</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get first timestamp greater or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span><span class="p">:</span><span class="n">point_index</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;start_ts must be an int or a pandas Timestamp.&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_before">[docs]</a>    <span class="k">def</span> <span class="nf">slice_n_points_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new TimeSeries, ending at `start_ts` and having at most `n` points.</span>

<span class="sd">        The provided timestamps will be included in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with length at most `n`, ending at `start_ts`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;n should be a positive integer.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">end_ts</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">end_ts</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get last timestamp smaller or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point_index</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="n">point_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;start_ts must be an int or a pandas Timestamp.&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_intersect"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_intersect">[docs]</a>    <span class="k">def</span> <span class="nf">slice_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a TimeSeries slice of this time series, where the time index has been intersected with the one</span>
<span class="sd">        provided in argument. Note that this method is in general *not* symmetric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other time series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series, containing the values of this series, over the time-span common to both time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.strip"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.strip">[docs]</a>    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a TimeSeries slice of this deterministic time series, where NaN-only entries at the beginning</span>
<span class="sd">        and the end of the series are removed. No entries after (and including) the first non-NaN entry and</span>
<span class="sd">        before (and including) the last non-NaN entry are removed.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series based on the original where NaN-only entries at start and end have been removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_start_idx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">()</span>
        <span class="n">new_end_idx</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>
        <span class="n">new_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">new_start_idx</span><span class="p">:</span><span class="n">new_end_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">new_series</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.longest_contiguous_slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.longest_contiguous_slice">[docs]</a>    <span class="k">def</span> <span class="nf">longest_contiguous_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_gap_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the largest TimeSeries slice of this deterministic time series that contains no gaps</span>
<span class="sd">        (contigouse all-NaN rows) larger than `max_gap_size`.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series constituting the largest slice of the original with no or bounded gaps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stripped_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">gaps</span><span class="p">()</span>
        <span class="n">relevant_gaps</span> <span class="o">=</span> <span class="n">gaps</span><span class="p">[</span><span class="n">gaps</span><span class="p">[</span><span class="s1">&#39;gap_size&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_gap_size</span><span class="p">]</span>

        <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">max_slice_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_slice_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">relevant_gaps</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;gap_start&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">curr_slice_start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
                <span class="n">max_slice_end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;gap_start&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
            <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;gap_end&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

        <span class="k">if</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">curr_slice_start</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
            <span class="n">max_slice_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stripped_series</span><span class="p">[</span><span class="n">max_slice_start</span><span class="p">:</span><span class="n">max_slice_end</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.rescale_with_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.rescale_with_value">[docs]</a>    <span class="k">def</span> <span class="nf">rescale_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_at_first_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new TimeSeries, which is a multiple of this TimeSeries such that</span>
<span class="sd">        the first value is `value_at_first_step`.</span>
<span class="sd">        (Note: numerical errors can appear with `value_at_first_step &gt; 1e+24`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value_at_first_step</span>
<span class="sd">            The new value for the first entry of the TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, where the first value is `value_at_first_step` and other values</span>
<span class="sd">            have been scaled accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raise_if_not</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Cannot rescale with first value 0.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">value_at_first_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">))</span>  <span class="c1"># TODO: test</span>
        <span class="n">new_series</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_series</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.shift"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the time axis of this TimeSeries by `n` time steps.</span>

<span class="sd">        If :math:`n &gt; 0`, shifts in the future. If :math:`n &lt; 0`, shifts in the past.</span>

<span class="sd">        For example, with :math:`n=2` and `freq=&#39;M&#39;`, March 2013 becomes May 2013.</span>
<span class="sd">        With :math:`n=-2`, March 2013 becomes Jan 2013.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The number of time steps (in self.freq unit) to shift by. Can be negative.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with a shifted index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TimeSeries.shift(): converting n to int from </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">except</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">OverflowError</span><span class="p">(</span><span class="s2">&quot;the add operation between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> will &quot;</span>
                                    <span class="s2">&quot;overflow&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="n">new_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="n">ts</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">new_time_index</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.diff"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.diff">[docs]</a>    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
             <span class="n">periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
             <span class="n">dropna</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a differenced time series. This is often used to make a time series stationary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            Optionally, a positive integer indicating the number of differencing steps (default = 1).</span>
<span class="sd">            For instance, n=2 computes the second order differences.</span>
<span class="sd">        periods</span>
<span class="sd">            Optionally, periods to shift for calculating difference. For instance, periods=12 computes the</span>
<span class="sd">            difference between values at time `t` and times `t-12`.</span>
<span class="sd">        dropna</span>
<span class="sd">            Whether to drop the missing values after each differencing steps. If set to False, the corresponding</span>
<span class="sd">            first `periods` time steps will be filled with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries constructed after differencing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
             <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;n&#39; must be a positive integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
             <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;periods&#39; must be an integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_compute_diff</span><span class="p">(</span><span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1"># xarray doesn&#39;t support Pandas &quot;period&quot; so compute diff() ourselves</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dropna</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will have the same size and filled with NaNs</span>
                <span class="n">new_xa_</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will be shorter</span>
                <span class="n">new_xa_</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">new_xa_</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.has_same_time_as"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.has_same_time_as">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether this TimeSeries and another one have the same time index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if both TimeSeries have the same index, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.append"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends another TimeSeries to this TimeSeries, along the time axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A second TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, obtained by appending the second TimeSeries to the first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">has_datetime_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_datetime_index</span><span class="p">,</span>
                     <span class="s1">&#39;Both series must have the same type of time index (either DatetimeIndex or Int64Index).&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                     <span class="s1">&#39;Appended TimeSeries must have the same frequency as the current one&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">n_components</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
                     <span class="s1">&#39;Both series must have the same number of components.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
                     <span class="s1">&#39;Both series must have the same number of components.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                         <span class="s1">&#39;Appended TimeSeries must start one time step after current one.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="n">other_xa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">()</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other_xa</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                              <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                              <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span><span class="p">),</span>
                                      <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">})</span>

        <span class="c1"># new_xa = xr.concat(objs=[self._xa, other_xa], dim=str(self._time_dim))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">new_xa</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">dims_or_levels</span><span class="o">=</span><span class="n">new_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># TODO: fill_missing_dates takes a performance hit; do we need it here</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">new_xa</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.append_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append_values">[docs]</a>    <span class="k">def</span> <span class="nf">append_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends values to current TimeSeries, to the given indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            An array with the values to append.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with the new values appended</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO test</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                                                            <span class="n">times</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                                                            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.update"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span>
               <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the TimeSeries with the new values provided.</span>
<span class="sd">        If indices are not in original TimeSeries, they will be discarded.</span>
<span class="sd">        Use `numpy.nan` to ignore a specific index in a series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index</span>
<span class="sd">            A `pandas.DateTimeIndex` containing the indices to replace.</span>
<span class="sd">        values</span>
<span class="sd">            An array containing the values to replace (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with updated values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: I don&#39;t think this is needed... probably better to just create a new TimeSeries</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;TimeSeries.update() is not supported anymore.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.stack"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.stack">[docs]</a>    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stacks another univariate or multivariate TimeSeries with the same time index on top of</span>
<span class="sd">        the current one (along the component axis), and returns the newly formed multivariate TimeSeries that includes</span>
<span class="sd">        all the components of `self` and of `other`.</span>

<span class="sd">        The resulting TimeSeries will have the same name for its time dimension as this TimeSeries, and the</span>
<span class="sd">        same number of samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A TimeSeries instance with the same index and the same number of samples as the current one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new multivariate TimeSeries instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="s1">&#39;The indices of the two TimeSeries instances &#39;</span>
                     <span class="s1">&#39;must be equal&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span> <span class="s1">&#39;Two series can be stacked only if they &#39;</span>
                                                        <span class="s1">&#39;have the same number of samples.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="n">other_xa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span>
            <span class="n">new_other_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">other_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                                        <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_other_xa</span> <span class="o">=</span> <span class="n">other_xa</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">,</span> <span class="n">new_other_xa</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># we call the factory method here to disambiguate column names if needed.</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">new_xa</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_component"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_component">[docs]</a>    <span class="k">def</span> <span class="nf">univariate_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves one of the components of the current TimeSeries instance</span>
<span class="sd">        and returns it as new univariate TimeSeries instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index</span>
<span class="sd">            An zero-indexed integer indicating which component to retrieve. If components have names,</span>
<span class="sd">            this can be a string with the component&#39;s name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new univariate TimeSeries instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.add_datetime_attribute"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_datetime_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">add_datetime_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">one_hot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new TimeSeries instance with one (or more) additional component(s) that contain an attribute</span>
<span class="sd">        of the time index of the current series specified with `attribute`, such as &#39;weekday&#39;, &#39;day&#39; or &#39;month&#39;.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            A pd.DatatimeIndex attribute which will serve as the basis of the new column(s).</span>
<span class="sd">        one_hot</span>
<span class="sd">            Boolean value indicating whether to add the specified attribute as a one hot encoding</span>
<span class="sd">            (results in more columns).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            New TimeSeries instance enhanced by `attribute`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">datetime_attribute_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">one_hot</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.add_holidays"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_holidays">[docs]</a>    <span class="k">def</span> <span class="nf">add_holidays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">country_code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                     <span class="n">prov</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a binary univariate component to the current series that equals 1 at every index that</span>
<span class="sd">        corresponds to selected country&#39;s holiday, and 0 otherwise. The frequency of the TimeSeries is daily.</span>

<span class="sd">        Available countries can be found `here &lt;https://github.com/dr-prodigy/python-holidays#available-countries&gt;`_.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        country_code</span>
<span class="sd">            The country ISO code</span>
<span class="sd">        prov</span>
<span class="sd">            The province</span>
<span class="sd">        state</span>
<span class="sd">            The state</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance, enhanced with binary holiday component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">holidays_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">country_code</span><span class="p">,</span> <span class="n">prov</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.resample"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;pad&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an reindexed time series with a given frequency.</span>
<span class="sd">        Provided method is used to fill holes in reindexed TimeSeries, by default &#39;pad&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq</span>
<span class="sd">            The new time difference between two adjacent entries in the returned TimeSeries.</span>
<span class="sd">            A DateOffset alias is expected.</span>
<span class="sd">        method:</span>
<span class="sd">            Method to fill holes in reindexed TimeSeries (note this does not fill NaNs that already were present):</span>

<span class="sd">            ‘pad’: propagate last valid observation forward to next valid</span>

<span class="sd">            ‘backfill’: use NEXT valid observation to fill.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A reindexed TimeSeries with given frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">freq</span><span class="p">})</span>

        <span class="c1"># TODO: check</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pad&#39;</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">pad</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bfill&#39;</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">backfill</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown method: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.is_within_range"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.is_within_range">[docs]</a>    <span class="k">def</span> <span class="nf">is_within_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a given timestamp or integer is withing the time interval of this time series.</span>
<span class="sd">        If a timestamp is provided, it does not need to be an element of the time index of the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts</span>
<span class="sd">            The `pandas.Timestamp` (if indexed with DatetimeIndex) or integer (if indexed with Int64Index) to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether `ts` is contained within the interval of this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.map"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
                      <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>  <span class="c1"># noqa: E501</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the function `fn` elementwise to all values in this TimeSeries.</span>
<span class="sd">        Returns a new TimeSeries instance. If `fn` takes 1 argument it is simply applied elementwise.</span>
<span class="sd">        If it takes 2 arguments, it is applied elementwise on the (timestamp, value) tuples.</span>

<span class="sd">        At the moment this function works only on deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn</span>
<span class="sd">            Either a function which takes a value and returns a value ie. `f(x) = y`</span>
<span class="sd">            Or a function which takes a value and its timestamp and returns a value ie. `f(timestamp, x) = y`</span>
<span class="sd">            The type of `timestamp` is either `pd.Timestamp` (if the series is indexed with a DatetimeIndex),</span>
<span class="sd">            or an integer otherwise (if the series is indexed with an Int64Index).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fn should be callable&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fn must have either one or two arguments and return a single value&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inspect.signature(fn) failed. Try wrapping fn in a lambda, e.g. lambda x: fn(x)&quot;</span><span class="p">),</span>
                          <span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># simple map function f(x)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># map function uses timestamp f(timestamp, x)</span>
            <span class="k">def</span> <span class="nf">apply_fn_wrapper</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">timestamp</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span>
                <span class="k">return</span> <span class="n">row</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">fn</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">apply_fn_wrapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fn must have either one or two arguments&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the `TimeSeries` object to a JSON String</span>

<span class="sd">        At the moment this function works only on deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A JSON String representing the time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;split&#39;</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="s1">&#39;iso&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.plot"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">new_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">central_quantile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
             <span class="n">low_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
             <span class="n">high_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
             <span class="o">*</span><span class="n">args</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper method around `xarray.DataArray.plot()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_plot</span>
<span class="sd">            whether to spawn a new Figure</span>
<span class="sd">        central_quantile</span>
<span class="sd">            The quantile (between 0 and 1) to plot as a &quot;central&quot; value, if the series is stochastic (i.e., if</span>
<span class="sd">            it has multiple samples). This will be applied on each component separately (i.e., to display quantiles</span>
<span class="sd">            of the components&#39; marginal distributions). For instance, setting `central_quantile=0.5` will plot the</span>
<span class="sd">            median of each component. `central_quantile` can also be set to &#39;mean&#39;.</span>
<span class="sd">        low_quantile</span>
<span class="sd">            The quantile to use for the lower bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `confidence_low_quantile` is None (default 0.05).</span>
<span class="sd">        high_quantile</span>
<span class="sd">            The quantile to use for the upper bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `high_quantile` is None (default 0.95).</span>
<span class="sd">        args</span>
<span class="sd">            some positional arguments for the `plot()` method</span>
<span class="sd">        kwargs</span>
<span class="sd">            some keyword arguments for the `plot()` method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_confidence_intvls</span> <span class="o">=</span> <span class="mf">0.25</span>

        <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">!=</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">central_quantile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">central_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">,</span>
                         <span class="s1">&#39;central_quantile must be either &quot;mean&quot;, or a float between 0 and 1.&#39;</span><span class="p">,</span>
                         <span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">low_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.</span> <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">high_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.</span><span class="p">,</span>
                         <span class="s1">&#39;confidence interval low and high quantiles must be between 0 and 1.&#39;</span><span class="p">,</span>
                         <span class="n">logger</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span> <span class="k">if</span> <span class="n">new_plot</span> <span class="k">else</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;figure&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;figure&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;figure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;lw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Number of components is larger than 10 (</span><span class="si">{}</span><span class="s1">). Plotting only the first 10 components.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
            <span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">component</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
            <span class="n">comp_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;figure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>

            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">central_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># temporarily set alpha to 1 to plot the central value (this way alpha impacts only the confidence intvls)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;alpha&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">label_to_use</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> \
                           <span class="k">else</span> <span class="s1">&#39;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">comp_name</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_to_use</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">central_series</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">color_used</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alpha_confidence_intvls</span>

            <span class="c1"># Optionally show confidence intervals</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">low_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">low_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">high_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">high_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">low_series</span><span class="p">,</span> <span class="n">high_series</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_used</span><span class="p">,</span>
                                     <span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="n">alpha_confidence_intvls</span> <span class="k">if</span> <span class="s1">&#39;alpha&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">name</span><span class="p">);</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple statistics. At the moment these work only on deterministic series, and are wrapped around Pandas.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.mean"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.var"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.std"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ddof</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.skew"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.kurtosis"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.kurtosis">[docs]</a>    <span class="k">def</span> <span class="nf">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.min"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.max"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.sum"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.median"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.median">[docs]</a>    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.autocorr"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.autocorr">[docs]</a>    <span class="k">def</span> <span class="nf">autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">autocorr</span><span class="p">(</span><span class="n">lag</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.describe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">percentiles</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dunder methods</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">_combine_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;TimeSeries&#39;</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                        <span class="n">combine_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper function that allows us to combine this series with another one,</span>
<span class="sd">        directly applying an operation on their underlying numpy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;Attempted to perform operation on two TimeSeries &#39;</span>
                                                                <span class="s1">&#39;of unequal shapes.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_xa</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">combine_fn</span><span class="p">(</span><span class="n">new_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for + or add(): </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">-</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for - or sub(): </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for * or mul(): </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Attempted to raise a series to a negative power.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">**</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">**</span> <span class="n">s2</span><span class="p">)</span>  <span class="c1"># elementwise power</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for ** or pow(): </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s1">&#39;Cannot divide by 0.&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">all_values</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s1">&#39;Cannot divide by a TimeSeries with a value 0.&#39;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for / or truediv(): </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span>

    <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for &lt; : </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">series</span>  <span class="c1"># Note: we return a DataArray</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for &lt; : </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">series</span>  <span class="c1"># Note: we return a DataArray</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for &lt; : </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">series</span>  <span class="c1"># Note: we return a DataArray</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported operand type(s) for &lt; : </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">series</span>  <span class="c1"># Note: we return a DataArray</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xarray.DataArray&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries (DataArray)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xarray.DataArray&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries (DataArray)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;xarray.DataArray&#39;</span><span class="p">,</span> <span class="s1">&#39;TimeSeries (DataArray)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span>
                               <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">,</span>
                               <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                               <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                               <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">],</span>
                               <span class="nb">str</span><span class="p">,</span>
                               <span class="nb">int</span><span class="p">,</span>
                               <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span>
                               <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TimeSeries&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Allow indexing on darts TimeSeries.</span>

<span class="sd">        The supported index types are the following base types as a single value, a list or a slice:</span>
<span class="sd">        - pd.Timestamp -&gt; return a TimeSeries corresponding to the value(s) at the given timestamp(s).</span>
<span class="sd">        - str -&gt; return a TimeSeries including the column(s) (components) specified as str.</span>
<span class="sd">        - int -&gt; return a TimeSeries with the value(s) at the given row (time) index.</span>

<span class="sd">        `pd.DatetimeIndex` and `pd.Int64Index` are also supported and will return the corresponding value(s)</span>
<span class="sd">        at the provided time indices.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            slices use pandas convention of including both ends of the slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_check_dt</span><span class="p">():</span>
            <span class="n">raise_if_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span> <span class="s1">&#39;Attempted indexing a series with a DatetimeIndex or a timestamp, &#39;</span>
                                                   <span class="s1">&#39;but the series uses an Int64Index.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_range</span><span class="p">():</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span> <span class="s1">&#39;Attempted indexing a series with an Int64Index, &#39;</span>
                                               <span class="s1">&#39;but the series uses a DatetimeIndex.&#39;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1"># mutates the DataArray to make sure it contains the freq</span>
            <span class="n">inferred_freq</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">inferred_freq</span>
            <span class="k">if</span> <span class="n">inferred_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">inferred_freq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

        <span class="c1"># handle DatetimeIndex and Int64Index:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">_check_dt</span><span class="p">()</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="c1"># indexing may discard the freq so we restore it...</span>
            <span class="c1"># TODO: unit-test this</span>
            <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">):</span>
            <span class="n">_check_range</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">}))</span>

        <span class="c1"># handle slices:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">key</span><span class="p">}))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">}))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
                <span class="n">_check_dt</span><span class="p">()</span>

                <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="c1"># handle simple types:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">[</span><span class="n">key</span><span class="p">]}))</span>  <span class="c1"># have to put key in a list not to drop the dimension</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="n">key</span><span class="p">]}))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">_check_dt</span><span class="p">()</span>

            <span class="c1"># indexing may discard the freq so we restore it...</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="n">key</span><span class="p">]})</span>
            <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="c1"># handle lists:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># when string(s) are provided, we consider it as (a list of) component(s)</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">key</span><span class="p">}))</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">}))</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">_check_dt</span><span class="p">()</span>

                <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="n">raise_log</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The type of your index was not matched.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../_static/js/index.3da636dd464baa7582d2.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2021, Unit8 SA.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>